[["intro.html", "Chapter 2 A very brief introduction to R", " Chapter 2 A very brief introduction to R The R version of the RPMP content is very different to the regular Jamovi version, by virture of the fact that even though Jamovi is built on R, it isn’t necessarily built with R users first in mind. Rather, it’s built for users of SPSS and other platforms that may be used to a point and click approach. To clarify, there’s nothing wrong with this at all - one of Jamovi’s greatest strengths is how easy it is to use - but it means that the same procedures in R work a little differently. This chapter is not meant to be an exhaustive be-all end-all to how to use R. It will only go through enough to complete RPMP’s content. It will however introduce a couple of things that I think make for good starting habits using R, which is never a bad thing! "],["assignment-and-syntax.html", "2.1 Assignment and syntax", " 2.1 Assignment and syntax In R, assigning values/strings etc. to variables is slightly different to other languages. Instead of using equals signs, we use a left arrow &lt;- for assignment. For example: # Use this x &lt;- 5 # This works but isn&#39;t preferred x = 5 When it comes to naming variables and the like, the easiest/most readable way for most people is to separate words using an underscore. e.g. # this is preferred variable_name # this is also very common variable.name # sentence case is also sometimes used VariableName # no spaces are allowed variable name # This will give you an error # some heathens use camel case variableName To view what has been assigned to a variable, you can simply write the variable name: # This is the variable we named earlier x ## [1] 5 "],["loading-packages.html", "2.2 Loading packages", " 2.2 Loading packages When you start a new R session, the first thing that you’ll want to do is load the packages that you need to use. Packages contain functions that augment/extend what R is capable of doing. Some packages occassionally come with data too, such as the palmerpenguins dataset. For now, we’ll load two packages for functions: the tidy verse and rstatix. The tidyverse is a huge package that contains a group of other packages designed for data manipulation, visualisation and cleaning. rstatix allows for simple statistical tests to be performed in an easy way. palmerpenguins comes with a dataset for practicing on. palmerpenguins loads a dataset named penguins that contains basic info on 3 species of penguins across 3 different islands. To load a package, call the library() function and enter the name of the package in brackets: library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.3 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.4 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(rstatix) ## ## Attaching package: &#39;rstatix&#39; ## ## The following object is masked from &#39;package:stats&#39;: ## ## filter library(palmerpenguins) 2.2.1 Tidyverse Many aspects of the tidyverse are reliant on the pipe operator, %&gt;%. This basically tells R to take a dataframe or output and pass it onto a function that comes directly afterwards. Any function that takes a data frame as its first argument can (theoretically) be piped, meaning that we can chain strings of functions together in one run in a readable way. See the example below: data %&gt;% function_1() %&gt;% function_2(do = &quot;this&quot;) %&gt;% function_3(avoid = &quot;that&quot;) in the hypothetical example above, we first take data, pass it to function 1, pass the output of that to function 2, and pass the output from function 2 to function 3. "],["wrangling-data-with-dplyr-and-others.html", "2.3 Wrangling data with dplyr and others", " 2.3 Wrangling data with dplyr and others dplyr is a package within the tidyverse for manipulating and wrangling data. select() lets you select the columns you want from a dataset. Simply specify the columns that you want by name. Below we take the species and island columns from the penguins dataset: x &lt;- penguins %&gt;% select(species, island) x ## # A tibble: 344 × 2 ## species island ## &lt;fct&gt; &lt;fct&gt; ## 1 Adelie Torgersen ## 2 Adelie Torgersen ## 3 Adelie Torgersen ## 4 Adelie Torgersen ## 5 Adelie Torgersen ## 6 Adelie Torgersen ## 7 Adelie Torgersen ## 8 Adelie Torgersen ## 9 Adelie Torgersen ## 10 Adelie Torgersen ## # ℹ 334 more rows filter() selects the rows that you want based on a certain condition. Here, we specify the column that want to filter by and state the condition (== means equals to). We can filter on multiple conditions; for example, filtering Adelie penguins by the year 2007: y &lt;- penguins %&gt;% filter(year == 2007, species == &quot;Adelie&quot;) y ## # A tibble: 50 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## 7 Adelie Torgersen 38.9 17.8 181 3625 ## 8 Adelie Torgersen 39.2 19.6 195 4675 ## 9 Adelie Torgersen 34.1 18.1 193 3475 ## 10 Adelie Torgersen 42 20.2 190 4250 ## # ℹ 40 more rows ## # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; You can also choose to filter out rows based on a condition by adding an exclamation mark in front of the column name. penguins %&gt;% filter(!year == 2007) ## # A tibble: 234 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Biscoe 39.6 17.7 186 3500 ## 2 Adelie Biscoe 40.1 18.9 188 4300 ## 3 Adelie Biscoe 35 17.9 190 3450 ## 4 Adelie Biscoe 42 19.5 200 4050 ## 5 Adelie Biscoe 34.5 18.1 187 2900 ## 6 Adelie Biscoe 41.4 18.6 191 3700 ## 7 Adelie Biscoe 39 17.5 186 3550 ## 8 Adelie Biscoe 40.6 18.8 193 3800 ## 9 Adelie Biscoe 36.5 16.6 181 2850 ## 10 Adelie Biscoe 37.6 19.1 194 3750 ## # ℹ 224 more rows ## # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; drop_na() is another useful starting function that simply removes all rows with NA/empty cells. If you enter it as is then it will clean the entire dataset; if you specify a column then it will remove all rows with NAs in that column. Below is an example of a pipe using these functions - going from selecting columns to filtering rows and finally cleaning up the empty cells. z &lt;- penguins %&gt;% select(species, body_mass_g, year) %&gt;% filter(year == 2009) %&gt;% drop_na() z ## # A tibble: 119 × 3 ## species body_mass_g year ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie 3725 2009 ## 2 Adelie 4725 2009 ## 3 Adelie 3075 2009 ## 4 Adelie 4250 2009 ## 5 Adelie 2925 2009 ## 6 Adelie 3550 2009 ## 7 Adelie 3750 2009 ## 8 Adelie 3900 2009 ## 9 Adelie 3175 2009 ## 10 Adelie 4775 2009 ## # ℹ 109 more rows "],["making-graphs-with-ggplot2.html", "2.4 Making graphs with ggplot2", " 2.4 Making graphs with ggplot2 ggplot2 is the tidyverse way of visualising data. The ‘gg’ in the name ggplot2 stands for grammar of graphics. The idea is that a graph is built by the same few components - a dataset, geoms (visual marks that represent data) and a coordinate system. A cheatsheet for ggplot2 can be found here. To start a plot, we first call the ggplot function. Here, we specify three of the main features of our plot - the dataset that we want to use, the x axis and the y axis. the x and y axes are wrapped within the aes() function, which defines our aesthetics. Here, we simply say which columns of our dataset should go on the x and y axes. Using the penguin dataset, we can start to visualise a scatter plot between bill length and bill depth like this: ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) However, notice that the plot is empty. This is because we haven’t defined any geoms, or actual plotting methods, in our plot. Refer to the cheatsheet for all of the possible geoms. For now, we will stick to basics. A scatter plot can be specified by adding geom_point(): ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() ## Warning: Removed 2 rows containing missing values (`geom_point()`). From here, we can change many things by adding or modifying our existing layers. If we want to colour the dots by sex (which is a column in the penguins data), we can do so by specifiyng colour = sex in our aes() function. ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() ## Warning: Removed 2 rows containing missing values (`geom_point()`). The axis labels aren’t very informative as they are. We can change this by adding labs(), which is a simple way of specifying x and y labels: ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() + labs(x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) ## Warning: Removed 2 rows containing missing values (`geom_point()`). To add a line of best fit (e.g. in the instance of regressions), add geom_smooth(method = \"lm\"). Specifying the method is important because by default, geom_smooth() will probably fit LOESS curves (local polynomial regressions). Note that if you’ve specified a colour/grouping variable, separate regression lines will be fitted for each group. By default, the line will also have standard error bands around it. You can turn this off by also specifying se = FALSE in the geom_smooth() call. ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() + labs(x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 2 rows containing non-finite values (`stat_smooth()`). ## Warning: Removed 2 rows containing missing values (`geom_point()`). geom_boxplot() will create boxplots. An example is below, with species on the x axis and body mass on the y: ggplot(data = penguins, aes(x = species, y = body_mass_g)) + geom_boxplot() ## Warning: Removed 2 rows containing non-finite values (`stat_boxplot()`). Finally, if you want to split plots by a certain variable, add facet_wrap() to our call. You need to specify what variable/column you want to split by, with a tilde in front. For example, if we wanted to split the scatter plot by year: ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() + labs(x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) + facet_wrap(~year) ## Warning: Removed 2 rows containing missing values (`geom_point()`). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
