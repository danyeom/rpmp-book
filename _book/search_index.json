[["intro.html", "Chapter 2 A very brief introduction to R", " Chapter 2 A very brief introduction to R The R version of the RPMP content is very different to the regular Jamovi version, by virture of the fact that even though Jamovi is built on R, it isn’t necessarily built with R users first in mind. Rather, it’s built for users of SPSS and other platforms that may be used to a point and click approach. To clarify, there’s nothing wrong with this at all - one of Jamovi’s greatest strengths is how easy it is to use - but it means that the same procedures in R work a little differently. This chapter is not meant to be an exhaustive be-all end-all to how to use R. It will only go through enough to complete RPMP’s content. It will however introduce a couple of things that I think make for good starting habits using R, which is never a bad thing! For a far more comprehensive and rigorous overview of how to program in R, there is no better guide than R 4 Data Science (R4DS) by Hadley Wickham: https://r4ds.had.co.nz/. In general, I am a huge proponent of the ‘tidy’ workflow of data analysis. While it was originally designed for data science in mind, I think it’s a valuable model for psychological science as well: "],["assignment-and-syntax.html", "2.1 Assignment and syntax", " 2.1 Assignment and syntax 2.1.1 Basic syntax In R, assigning values/strings etc. to variables is slightly different to other languages. Instead of using equals signs, we use a left arrow &lt;- for assignment. For example: # Use this x &lt;- 5 # This works but isn&#39;t preferred x = 5 When it comes to naming variables and the like, the easiest/most readable way for most people is to separate words using an underscore. e.g. # this is preferred variable_name # this is also very common variable.name # sentence case is also sometimes used VariableName # no spaces are allowed variable name # This will give you an error # some heathens use camel case variableName To view what has been assigned to a variable, you can simply write the variable name: # This is the variable we named earlier x ## [1] 5 2.1.2 Variable types Like many programming languages, R works by manipulating different types of variables. Knowing how to work with these different variables is fairly essential to using R, so here is a brief overview. First, we have our most basic classes of variables. The first is numeric: var_a &lt;- 5.25 var_a ## [1] 5.25 A special form of a numeric variable is an integer variable, which is used for whole numbers. var_b &lt;- 6 var_b ## [1] 6 The second is character, which is used for text (or strings in programming language). Characters must be enclosed with speech marks: var_c &lt;- &quot;This is a string&quot; var_c ## [1] &quot;This is a string&quot; Finally, we have logical variables, which can take on the form of TRUE or FALSE. TRUE and FALSE (or alternatively T or F) are special values in R that, as their names suggest, are used to indicate when a certain value is true or false. var_d &lt;- TRUE var_d ## [1] TRUE You can check the class of any given variable using the class() function in base R. class(var_a) ## [1] &quot;numeric&quot; class(var_b) ## [1] &quot;numeric&quot; class(var_c) ## [1] &quot;character&quot; class(var_d) ## [1] &quot;logical&quot; 2.1.3 Data structures Of course, in R we don’t work with single values (often). We instead work with larger data structures. While there are a number of data structures in R, by and large the main one we will work with are data frames. Data frames are flexible, row-column structures that contain data. R works best when data frames are in a tidy format. In a tidy format: Each variable is its own column Each observation (participant, object) is its own row Each value is in its own cell. Figure 2.1: Adapted from R4DS. Here is an example of a data frame in tidy format. Note how each column corresponds to a different variable, or piece of data that we’re interested in. Each column is also clearly labelled, so it is clear what it represents. Each row corresponds to an observation (a single penguin, in this case). So, the first row represnts an Adelie penguin on Torgersen Island, with a bill length of 39.1mm etc etc. library(palmerpenguins) penguins ## # A tibble: 344 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## 7 Adelie Torgersen 38.9 17.8 181 3625 ## 8 Adelie Torgersen 39.2 19.6 195 4675 ## 9 Adelie Torgersen 34.1 18.1 193 3475 ## 10 Adelie Torgersen 42 20.2 190 4250 ## # ℹ 334 more rows ## # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; For the purposes of RPMP you won’t need to create any data frames, but you will need to know how to read files in. More on this on the next page! "],["packages-and-functions.html", "2.2 Packages and functions", " 2.2 Packages and functions The beauty of R is that its functionality is essentially limitless; its open-source nature and strong community mean that new functions and capabilities are regularly made for R. These new functions augment/extend what R is capable of doing, and are generally designed in the form of packages. To provide a very simple explanation of what packages are, packages are a collection of code that provide new functions in R. Some packages occassionally come with data too, such as the palmerpenguins package. 2.2.1 Loading packages When you start a new R session, the first thing that you’ll want to do is load the packages that you need to use. For now, we’ll load two packages for functions: tidyverse and rstatix. tidyverse is a huge package that contains a group of other packages designed for data manipulation, visualisation and cleaning. rstatix allows for simple statistical tests to be performed in an easy way. palmerpenguins comes with a dataset for practicing on. palmerpenguins loads a dataset named penguins that contains basic info on 3 species of penguins across 3 different islands. To load a package, call the library() function and enter the name of the package in brackets: library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.3 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.4 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(rstatix) ## ## Attaching package: &#39;rstatix&#39; ## ## The following object is masked from &#39;package:stats&#39;: ## ## filter library(palmerpenguins) 2.2.2 Tidyverse The tidyverse is a mega-collection of phenomenal packages that fundamentally change how to interface with R. The tidyverse provides packages for things like: Wrangling data Reading and writing data Making graphs Tidying and reshaping data Scraping the web The tidyverse is probably the single most popular suite of packages for R because of the functionality it provides. All of the tidyverse packages are written in consistent syntax, generally use very easy language that has an emphasis on verbs (i.e. you’re telling R to do something) and integrate seamlessly with each other and R. The tidyverse is a philosophy of R just as much as it is a suite of functions, and is part of what makes R so powerful today. Many aspects of the tidyverse are reliant on the pipe operator, %&gt;%. This basically tells R to take a dataframe or output and pass it onto a function that comes directly afterwards. Any function that takes a data frame as its first argument can (theoretically) be piped, meaning that we can chain strings of functions together in one run in a readable way. See the example below: data %&gt;% function_1() %&gt;% function_2(do = &quot;this&quot;) %&gt;% function_3(avoid = &quot;that&quot;) in the hypothetical example above, we first take data, and pass it to function 1. We then take the output of function 1 and pass that to function 2, which has the argument do = \"this\". Afterwards, we take the output of function 2 and pass it to function 3. There are a number of clear benefits to the tidyverse way of doing things. These include: Functions are generally stated as verbs, which means that you’re always doing something with a function (and it’s clear what that something is) Piping avoids the cyclical hell of creating intermediate variables. Consider a non-tidyverse version of the code example above, written down below. This code is not only a bit of a pain to read, but is also clunky in that it generates several intermediate variables that aren’t all that useful (a lot of the time). output_1 &lt;- function_1(data) output_2 &lt;- function_2(output_1, do = &quot;this&quot;) output_3 &lt;- function_3(output_2, avoid = &quot;that&quot;) Piped code is generally quite easy to read. tidyverse also provides a consistent syntax for other packages! It provides a quasi-philosophy and style guide for developers to write their own packages to write ‘tidy’ packages. rstatix is a great example of this. Throughout this book you will see a lot of tidyverse! 2.2.3 The here() package Another staple bit of code you will see throughout RPMP is the here package. The official vignette for here summarises what this package does: The here package enables easy file referencing by using the top-level directory of a file project to easily build file paths. This is in contrast to using setwd(), which is fragile and dependent on the way you order your files on your computer. Alternatively, read the below quote from R goddess Jenny Bryan: If the first line of your #rstats script is setwd(\"C:\\Users\\jenny\\path\\that\\only\\I\\have\"), I will come into your lab and SET YOUR COMPUTER ON FIRE. In short, here() allows us to locate files in a relative manner as opposed to an absolute one. This is super super useful for sharing your code and data with other people, and ensuring that your scripts will run no matter where they are. We won’t get into project-oriented workflows for RPMP. However, imagine you have a folder structure like this: |-code |-----rpmp_week1.Rmd |-data |-----w1_dataset.csv |-output |-RPMP.rproj Normally, to locate a file on a disk you would generally have to give the entire pathway to that file. That could be something like \"C:\\Users\\Dan\\Documents\\Subjects\\RPMP\\data\\w1_dataset.csv\" - which is immensely unwieldy if we want to read in data - and won’t work the moment I give my script to someone else, as their folder structure could be completely different! The alternative with here could be as simple as: here(&quot;data&quot;, &quot;w1_dataset.csv&quot;) This tells R that I’m looking for something here in the data folder, specifically a file named w1_dataset.csv. As long as the relative positions are correct - i.e. the .csv file is in the data folder - R will know where to locate the file. You will see a lot of here() in this version of the RPMP guide because as you may appreciate, there are a lot of data files stored in all manner of folders. "],["wrangling-data-with-dplyr-and-others.html", "2.3 Wrangling data with dplyr and others", " 2.3 Wrangling data with dplyr and others dplyr is a package within the tidyverse for manipulating and wrangling data. dplyr is one of the most popular packages on R because it provides a suite of functions that are fairly essential to manipulating and working with data. Below is a brief overview of some of these functions, applied to the penguins dataset. 2.3.1 Selecting columns with select() select() lets you select the columns you want from a dataset. Simply specify the columns that you want by name. Below we take the species and island columns from the penguins dataset: penguins %&gt;% select(species, island) ## # A tibble: 344 × 2 ## species island ## &lt;fct&gt; &lt;fct&gt; ## 1 Adelie Torgersen ## 2 Adelie Torgersen ## 3 Adelie Torgersen ## 4 Adelie Torgersen ## 5 Adelie Torgersen ## 6 Adelie Torgersen ## 7 Adelie Torgersen ## 8 Adelie Torgersen ## 9 Adelie Torgersen ## 10 Adelie Torgersen ## # ℹ 334 more rows You can select columns via a number of ways: Simply by name, e.g. select(species, island) By their index or column number, e.g. select(1, 2) select(1:4) will select columns 1 to 4 select(-1) will select the last column By certain operator functions, such as starts_with() and ends_with(), e.g. ends_with(\"mm\") will select all columns that end with “mm” Combinations of the above also work. Removing columns is simply done by adding a minus sign - in front of the arguments for select, and are compatible with all of the options above. 2.3.2 Filtering rows with filter() filter() selects the rows that you want based on a certain condition. Here, we specify the column that want to filter by and state the condition (== means equals to). We can filter on multiple conditions; for example, filtering Adelie penguins by the year 2007: penguins %&gt;% filter(year == 2007, species == &quot;Adelie&quot;) ## # A tibble: 50 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## 7 Adelie Torgersen 38.9 17.8 181 3625 ## 8 Adelie Torgersen 39.2 19.6 195 4675 ## 9 Adelie Torgersen 34.1 18.1 193 3475 ## 10 Adelie Torgersen 42 20.2 190 4250 ## # ℹ 40 more rows ## # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; You can also choose to filter out rows based on a condition by adding an exclamation mark in front of the column name. penguins %&gt;% filter(!year == 2007) ## # A tibble: 234 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Biscoe 39.6 17.7 186 3500 ## 2 Adelie Biscoe 40.1 18.9 188 4300 ## 3 Adelie Biscoe 35 17.9 190 3450 ## 4 Adelie Biscoe 42 19.5 200 4050 ## 5 Adelie Biscoe 34.5 18.1 187 2900 ## 6 Adelie Biscoe 41.4 18.6 191 3700 ## 7 Adelie Biscoe 39 17.5 186 3550 ## 8 Adelie Biscoe 40.6 18.8 193 3800 ## 9 Adelie Biscoe 36.5 16.6 181 2850 ## 10 Adelie Biscoe 37.6 19.1 194 3750 ## # ℹ 224 more rows ## # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; drop_na() is another useful starting function that simply removes all rows with NA/empty cells. If you enter it as is then it will clean the entire dataset; if you specify a column then it will remove all rows with NAs in that column. Below is an example of a pipe using these functions - going from selecting columns to filtering rows and finally cleaning up the empty cells. penguins %&gt;% select(species, body_mass_g, year) %&gt;% filter(year == 2009) %&gt;% drop_na() ## # A tibble: 119 × 3 ## species body_mass_g year ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie 3725 2009 ## 2 Adelie 4725 2009 ## 3 Adelie 3075 2009 ## 4 Adelie 4250 2009 ## 5 Adelie 2925 2009 ## 6 Adelie 3550 2009 ## 7 Adelie 3750 2009 ## 8 Adelie 3900 2009 ## 9 Adelie 3175 2009 ## 10 Adelie 4775 2009 ## # ℹ 109 more rows 2.3.3 Creating new columns with mutate() mutate() is a function that lets you create new columns. This can be extremely useful for operations like recoding variables and transforming them. The nice thing about mutate() is that you can do all manner of operations without touching your original data. The basic workflow of mutate() looks like this: data %&gt;% mutate( new_column_1 = a_function(...), new_column_2 = another_function(...) ) This example code would create two new columns, named new_column_1 and new_column_2, with their respective values being whatever the functions were. For example, in the penguins dataset we have a variable called body_mass_g, which is the body mass of each penguin in grams. If we wanted to convert this to kilograms, we would need to divide each penguin’s value on this variable by 1000. mutate() makes this a piece of cake. Let’s also chain a select() command to only show the following variables: species, island, body_mass_g and sex. penguins %&gt;% select(species, island, body_mass_g, sex) %&gt;% mutate(body_mass_kg = body_mass_g/1000) ## # A tibble: 344 × 5 ## species island body_mass_g sex body_mass_kg ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 3750 male 3.75 ## 2 Adelie Torgersen 3800 female 3.8 ## 3 Adelie Torgersen 3250 female 3.25 ## 4 Adelie Torgersen NA &lt;NA&gt; NA ## 5 Adelie Torgersen 3450 female 3.45 ## 6 Adelie Torgersen 3650 male 3.65 ## 7 Adelie Torgersen 3625 female 3.62 ## 8 Adelie Torgersen 4675 male 4.68 ## 9 Adelie Torgersen 3475 &lt;NA&gt; 3.48 ## 10 Adelie Torgersen 4250 &lt;NA&gt; 4.25 ## # ℹ 334 more rows You can see now that we have a new column called body_mass_kg that has our new transformed variable. mutate() can also take functions (and likely will make up the majority of your use of it). For example, let’s say that we want to make a variable that takes the natural logarithm of bill length (for whatever reason). We could do this as follows using the log() function within our mutate() call: penguins %&gt;% select(species, island, bill_length_mm, bill_depth_mm) %&gt;% mutate(bill_length_log = log(bill_length_mm)) ## # A tibble: 344 × 5 ## species island bill_length_mm bill_depth_mm bill_length_log ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 3.67 ## 2 Adelie Torgersen 39.5 17.4 3.68 ## 3 Adelie Torgersen 40.3 18 3.70 ## 4 Adelie Torgersen NA NA NA ## 5 Adelie Torgersen 36.7 19.3 3.60 ## 6 Adelie Torgersen 39.3 20.6 3.67 ## 7 Adelie Torgersen 38.9 17.8 3.66 ## 8 Adelie Torgersen 39.2 19.6 3.67 ## 9 Adelie Torgersen 34.1 18.1 3.53 ## 10 Adelie Torgersen 42 20.2 3.74 ## # ℹ 334 more rows 2.3.4 Summarising data with summarise() and group_by() Finally, sometimes we will want to summarise data - for example, to calculate basic features such as descriptives or for plotting. To do that, we can use the function summarise() (or summarize() for American users). summarise() works very similarly to mutate(). data %&gt;% summarise( summary_1 = a_function(...), summary_2 = another_function(...) ) The difference is that while mutate() retains the features of your data, summarise() will instead collapse it. To illustrate, let’s say we want to calculate a) how many penguins there are (with the function n()) and b) the mean body mass (with the mean() function). penguins %&gt;% summarise( n_penguins = n(), mean_mass = mean(body_mass_g, na.rm = TRUE) ) ## # A tibble: 1 × 2 ## n_penguins mean_mass ## &lt;int&gt; &lt;dbl&gt; ## 1 344 4202. This is… good and all, but consider what we’ve just done. We’ve just calculated the number of penguins and the mean body mass across the entire dataset. However, that may not necessarily be meaningful, particularly in this instance where we have meaningful groups within the data. For example, the above mean collapses across years, which may not be appropriate. Enter in another function called group_by(). As the name implies, group_by() will perform operations per a grouping variable that you specify. group_by() works especially well with summarise, because the idea is something like this: data %&gt;% group_by(variable) %&gt;% # Tell R to group the subsequent output by this variable summarise( summary_1 = a_function(...), summary_2 = another_function(...) ) %&gt;% ungroup() # Tell R grouping is no longer needed Let’s put this into practice by calculating the n and mean per year. Notice how the output now calculates n and the mean body mass per year, which is much more informative! penguins %&gt;% group_by(year) %&gt;% summarise( n_penguins = n(), mean_mass = mean(body_mass_g, na.rm = TRUE) ) %&gt;% ungroup() ## # A tibble: 3 × 3 ## year n_penguins mean_mass ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2007 110 4125. ## 2 2008 114 4267. ## 3 2009 120 4210. Naturally, group_by() can group using multiple variables. This is easy to do so as well penguins %&gt;% group_by(year, island) %&gt;% summarise( n_penguins = n(), mean_mass = mean(body_mass_g, na.rm = TRUE) ) ## `summarise()` has grouped output by &#39;year&#39;. You can override using the ## `.groups` argument. ## # A tibble: 9 × 4 ## # Groups: year [3] ## year island n_penguins mean_mass ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2007 Biscoe 44 4741. ## 2 2007 Dream 46 3684. ## 3 2007 Torgersen 20 3763. ## 4 2008 Biscoe 64 4628. ## 5 2008 Dream 34 3779. ## 6 2008 Torgersen 16 3856. ## 7 2009 Biscoe 60 4793. ## 8 2009 Dream 44 3691. ## 9 2009 Torgersen 16 3489. Suddenly this is much more informative - we can now do calculations/operations per year and island, which provides a lot more nuance. 2.3.5 Some other handy tidyverse functions As stated at the start of this chapter, this book will only cover enough R functions to provide you with an understanding of what goes on in this book and how. Nonetheless, there are so many tidyverse functions out there that are worth exploring and knowing about. Below is a brief list of some other functions from dplyr you may wish to keep in mind. To find out what a given function does in more detail, you just need to type ?function into the R console to search for its documentation (or ??x to do a broad search). Note that all of these are dplyr functions, so need to be piped from a dataset like usual. arrange() will sort your rows by a variable you specify. For example, if you wanted to sort the penguins dataset by island, you could use arrange(island) (or arrange(desc(island)) for descending order). distinct() will give you all unique values in a given column. distinct(island), for instance, will give you each unique island name. rename() will let you rename columns. `relocate() will let you rearrange the column order. The slice() set of functions is another way of subsetting rows based on their position. "],["making-graphs-with-ggplot2.html", "2.4 Making graphs with ggplot2", " 2.4 Making graphs with ggplot2 ggplot2 is the tidyverse way of visualising data. The ‘gg’ in the name ggplot2 stands for grammar of graphics. The idea is that a graph is built by the same few components - a dataset, geoms (visual marks that represent data) and a coordinate system. A cheatsheet for ggplot2 can be found here. To start a plot, we first call the ggplot function. Here, we specify three of the main features of our plot - the dataset that we want to use, the x axis and the y axis. the x and y axes are wrapped within the aes() function, which defines our aesthetics. Here, we simply say which columns of our dataset should go on the x and y axes. Using the penguin dataset, we can start to visualise a scatter plot between bill length and bill depth like this: ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) However, notice that the plot is empty. This is because we haven’t defined any geoms, or actual plotting methods, in our plot. Refer to the cheatsheet for all of the possible geoms. For now, we will stick to basics. A scatter plot can be specified by adding geom_point(): ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() ## Warning: Removed 2 rows containing missing values (`geom_point()`). From here, we can change many things by adding or modifying our existing layers. If we want to colour the dots by sex (which is a column in the penguins data), we can do so by specifiyng colour = sex in our aes() function. ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() ## Warning: Removed 2 rows containing missing values (`geom_point()`). The axis labels aren’t very informative as they are. We can change this by adding labs(), which is a simple way of specifying x and y labels: ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() + labs(x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) ## Warning: Removed 2 rows containing missing values (`geom_point()`). To add a line of best fit (e.g. in the instance of regressions), add geom_smooth(method = \"lm\"). Specifying the method is important because by default, geom_smooth() will probably fit LOESS curves (local polynomial regressions). Note that if you’ve specified a colour/grouping variable, separate regression lines will be fitted for each group. By default, the line will also have standard error bands around it. You can turn this off by also specifying se = FALSE in the geom_smooth() call. ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() + labs(x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 2 rows containing non-finite values (`stat_smooth()`). ## Warning: Removed 2 rows containing missing values (`geom_point()`). geom_boxplot() will create boxplots. An example is below, with species on the x axis and body mass on the y: ggplot(data = penguins, aes(x = species, y = body_mass_g)) + geom_boxplot() ## Warning: Removed 2 rows containing non-finite values (`stat_boxplot()`). Finally, if you want to split plots by a certain variable, add facet_wrap() to our call. You need to specify what variable/column you want to split by, with a tilde in front. For example, if we wanted to split the scatter plot by year: ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) + geom_point() + labs(x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) + facet_wrap(~year) ## Warning: Removed 2 rows containing missing values (`geom_point()`). From here, there are so many things you can do with ggplot - and it helps to get creative! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
